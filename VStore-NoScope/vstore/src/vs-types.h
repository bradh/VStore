//
// Created by xzl on 12/24/17.
//

/* serialization code from boost example
 *
 * NOTE: if the serialization becomes a perf hotspot, try YAS
 * https://github.com/thekvs/cpp-serializers
 * https://github.com/niXman/yas
 *
 * */

#ifndef VIDEO_STREAMER_MSGFMT_H
#define VIDEO_STREAMER_MSGFMT_H

#include <memory> // shared_ptr

#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

#include <zmq.hpp>

#include "mm.h"
#include "config.h"

namespace vs {

//	using cid_t = uint64_t; /* chunk id type */

	/* can use bit field to adjust field width. e.g.
	 * unsigned int stream_id :
	 *
	 * NB: the byte order also affects how lmdb compares keys
	 */

	using ts_t = uint32_t; /* type for video time, in ms */
	using seq_t = unsigned int; /* type for chunk/frame sequence number in a stream */

	/* globally unique. persistent. */
	struct cid_t {
		union {
			struct {
				uint32_t stream_id; /* global */
				ts_t ts;
			};

			uint64_t as_uint;

			static_assert(sizeof(stream_id) + sizeof(ts) <= sizeof(as_uint),
										"size violation");
		};

		cid_t (uint64_t const & x) : as_uint(x) { }
		cid_t () { }
	};

#if 0
	struct data_desc {
	private:
		friend class boost::serialization::access;

		// When the class Archive corresponds to an output archive, the
		// & operator is defined similar to <<.  Likewise, when the class Archive
		// is a type of input archive the & operator is defined similar to >>.
		template<class Archive>
		void serialize(Archive &ar, const unsigned int version) {
			ar & id;
			ar & length_ms;
			ar & size;
		}

	public:

		uint64_t id;
		uint64_t length_ms;
		uint64_t size; /* chunk size, in bytes */

	public:
		data_desc() {};

		data_desc(uint64_t key, uint64_t length, uint64_t sz) :
				id(key), length_ms(length), size(sz) {}
	};
#endif

#if 1
	enum data_type {
		TYPE_CHUNK = 0,
		TYPE_RAW_FRAME, 		/* raw frames loaded from db */
		TYPE_DECODED_FRAME, /* decoded on the fly */

		TYPE_CHUNK_EOF,			/* end of the specified time range */
		TYPE_RAW_FRAME_EOF, /* end of the specified time range */
		TYPE_DECODED_FRAME_EOF, /* end of the current chunk */

		TYPE_INVALID
	};

#define is_type_eof(x) \
	(x == TYPE_CHUNK_EOF \
|| x == TYPE_RAW_FRAME_EOF \
|| x == TYPE_DECODED_FRAME_EOF)

#define is_type_data(x) \
		(x == TYPE_CHUNK \
|| x == TYPE_RAW_FRAME \
|| x == TYPE_DECODED_FRAME)

#define is_type_frame(x) \
		(x == TYPE_RAW_FRAME \
|| x == TYPE_DECODED_FRAME)

	/* defined in stream-info */
	extern std::array<const char *, TYPE_INVALID + 1> data_type_str;

//	std::array<const char *, TYPE_INVALID + 1> data_type_str {
//		"chunk",
//		"raw_frame",
//		"decoded_frame",
//		"invalid"
//	};

	struct data_desc {

	/* each frame is often hundreds KB. so tens B desc should be fine */

	public:
		int type;  /* enum data_type */

		/* encodes both stream_id and ts.
		 *
		 * for TYPE_CHUNK and TYPE_RAW_FRAME, it carries the cid as the key loaded
		 * from db.
		 * for TYPE_DECODED_FRAME, it carries the cid of the encoded chunk loaded
		 * from db */
		cid_t cid;

		/* seq number in transmission.
		 * generated by sender on the fly. must be contiguous.
		 *
		 * if source emits encoded chunks, it does not know # frames per chunk
		 * until decoding. */
		seq_t c_seq; /* chunk seq */
		seq_t f_seq; /* frame seq */
		int tid; /* thread id */

#if 0
		/* for TYPE_RAW_FRAME */
		int fid;    /* frame id. -1 means invalid, there's no more frame */
		int width, height;
		int yuv_mode; /* 420/422/444 */

		/* for TYPE_CHUNK */
		int fps; /* used to derive fid */
		int length_ms;
#endif

	private:
		friend class boost::serialization::access;

		template<class Archive>
		void serialize(Archive &ar, const unsigned int version) {
			ar & type;
			ar & cid.as_uint;
			ar & c_seq;
			ar & f_seq;
			ar & tid;

#if 0
			ar & fid;
			ar & width;
			ar & height;
			ar & yuv_mode;

			ar & length_ms;
#endif
		}

	public:
		/* must specify type */
		data_desc(int type) : type (type) {};

		data_desc() : type (TYPE_INVALID) {};

		/* for dbg */
		std::string to_string() {
			return string_format("type %s cid (stream_id %u ts %lu) c_seq %d f_seq %d tid %d",
													 data_type_str[type], cid.stream_id, cid.ts, c_seq, f_seq, tid);
		}

	};
#endif

	/* desc for a substream */
	struct stream_desc {
		int stream_id;	/* global id for this stream. -1 means invalid */

		std::string db_path; /* in fs */

		bool is_encoded;

		int width, height;
		int fps;

		/* for raw video */
		int yuv_mode; /* 420/422/444. */

		ts_t start, duration;

		template<class Archive>
		void serialize(Archive &ar, const unsigned int version) {
			ar & stream_id;
			ar & db_path;		// don't need to send this over?

			ar & width;
			ar & height;
			ar & fps;

			ar & yuv_mode;

			ar & start;
			ar & duration;
		}
	};

/* work progress feedback from downstream */
	enum fb_type {
		FB_CHUNK_DECODED = 0,
		FB_FRAME_CONSUMED
	};

	struct feedback {
		enum fb_type type;

		cid_t cid;
		int fid;

		/* todo: more */

		feedback() {};

		feedback(cid_t cid, int fid) : cid(cid), fid(fid) {};

		template<class Archive>
		void serialize(Archive &ar, const unsigned int version) {
			ar & cid.as_uint;
			ar & fid;
		}
	};

	struct data_chunk{
		uint8_t *dt;
	};

	struct chunk_info{
	public:
		//std::array<uint8_t*, 1382400>
		//uint8_t *chunk_data[5][1382400];
		uint8_t *chunk_ptr[5];
	};

} // namespace vs

/* return values */
#define VS_ERR_EOF_CHUNKS		1
#define VS_ERR_AGAIN				2

#endif //VIDEO_STREAMER_MSGFMT_H
